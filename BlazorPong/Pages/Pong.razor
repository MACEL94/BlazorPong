@page "/pong"
@using System.Threading
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.SignalR.Client

<style>
    #player1 {
        background-color: red;
        width: 20px;
        height: 100px;
        position: absolute;
        left: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("player1"))?.LeftPx ?? "100px");
        top: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("player1"))?.TopPx ?? "100px");
    }

    #player2 {
        background-color: green;
        width: 20px;
        height: 100px;
        position: absolute;
        left: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("player2"))?.LeftPx ?? "880px");
        top: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("player2"))?.TopPx ?? "100px");
    }

    #ball {
        background-color: blue;
        width: 20px;
        height: 20px;
        position: absolute;
        left: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("ball"))?.LeftPx ?? "500px");
        top: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("ball"))?.TopPx ?? "250px");
    }
</style>

<div id="message">@_message</div>

<div id="area">
    <div id="tophorizontalboundary"></div>
    <div id="leftverticalboundary"></div>
    @foreach (var go in _gameObjects)
    {
        // ball, player1 e player2
        <div id="@go.Id" draggable="@go.Draggable" @ondrag="@(e => MoveOnYAxisAndFlag(e, go))"></div>
    }
    <div id="bottomhorizontalboundary"></div>
    <div id="rightverticalboundary"></div>
</div>

@code {
    List<GameObject> _gameObjects = new List<GameObject>();
    HubConnection _connection;
    // Per non lasciare cliccare nulla fino a che non esiste una connessione reale
    bool _clickOnPageDisabled = true;
    Enums.ClientType _playerType;
    double _mouseOffset = 0;
    string _message;
    Timer _updateServerTimer;

    protected override async Task OnInitAsync()
    {
        // 44364 DEVELOPMENT(IIS)
        // 443 PROD o DEV BlazorPong
#if DEBUG
        _connection = new HubConnectionBuilder()
            .WithUrl("https://localhost/gamehub")
            .WithAutomaticReconnect()
            .Build();
#else
        _connection = new HubConnectionBuilder()
            .WithUrl("https://blazorpong-dev-as.azurewebsites.net/gamehub")
            .WithAutomaticReconnect()
            .Build();
#endif

        _connection.On<GameObject>("UpdateGameObjectPositionOnClient", this.UpdateGameObjectPositionOnClient);
        await _connection.StartAsync();

        // Ora che la connessione è presente, mandiamo gli oggetti al server
        await _connection.SendAsync("AddGameObjectOnServer", "ball");
        await _connection.SendAsync("AddGameObjectOnServer", "player1");
        await _connection.SendAsync("AddGameObjectOnServer", "player2");

        // Ricavo che tipo di player sono(1, 2 o spettatore)
        _playerType = await _connection.InvokeAsync<Enums.ClientType>("GetClientType");

        switch (_playerType)
        {
            case Enums.ClientType.Player1:
                _message = "Sei il player1";
                break;
            case Enums.ClientType.Player2:
                _message = "Sei il player2";
                break;
            default:
                _message = "Sei uno spettatore";
                break;
        }

        this.InitializeGameObjects();

        _clickOnPageDisabled = false;

        // Ogni decimo di secondo controlliamo se necessario fare l'update delle collisioni al server e in caso lo mandiamo
        // Iniziamo un secondo dopo l'inizializzazione del timer
        _updateServerTimer = new Timer(UpdateServer, null, 1000, 100);
    }

    public void MoveOnYAxisAndFlag(UIDragEventArgs e, GameObject go)
    {
        if (!go.Draggable || _clickOnPageDisabled)
        {
            return;
        }

        // Calcolo prima di tutto l'offset del mouse se necessario
        if ((int)_mouseOffset == 0)
        {
            _mouseOffset = e.ClientY - go.Top;
        }

        // Non devo considerare l'offset nel calcolo
        go.Top = e.ClientY - _mouseOffset;

        // Il top può andare da un minimo di 10 a un massimo di 400(500 - altezza player)
        if (go.Top < 10)
        {
            go.Top = 10;
        }
        else if (go.Top > 400)
        {
            go.Top = 400;
        }

        // Ignoro l'asse x e quindi il left, che deve rimanere sempre uguale, e imposto come mosso e quindi da inviare l'oggetto
        // Di cui si è fatto il drag
        go.Moved = true;
    }

    private async void UpdateServer(object state)
    {
        if (_playerType == Enums.ClientType.Spectator)
        {
            return;
        }

        var tempGameObjects = new List<GameObject>();
        tempGameObjects.AddRange(_gameObjects);

        await UpdateGameObjectPositions();

        var playerGameObject = tempGameObjects.FirstOrDefault(go => go.Id.Equals((_playerType == Enums.ClientType.Player1 ? "player1" : "player2")));

        await CheckForCollisionsWithPlayerAndBall(playerGameObject, tempGameObjects);
    }

    private async Task CheckForCollisionsWithPlayerAndBall(GameObject playerGameObject, List<GameObject> tempGameObjects)
    {
        if (IsCollide(playerGameObject, tempGameObjects.FirstOrDefault(go => go.Id.Equals("ball"))))
        {
            if (_playerType == Enums.ClientType.Player1)
            {
                await _connection.SendAsync("OnPlayer1Hit");
            }
            else
            {
                await _connection.SendAsync("OnPlayer2Hit");
            }
        }
    }

    private bool IsCollide(GameObject gameObjectA, GameObject gameObjectB)
    {
        var aLeft = gameObjectA.Left;
        var aTop = gameObjectA.Top;
        var aWidth = gameObjectA.Width;
        var aHeight = gameObjectA.Height;
        var bLeft = gameObjectB.Left;
        var bTop = gameObjectB.Top;
        var bWidth = gameObjectB.Width;
        var bHeight = gameObjectB.Height;

        return !(
            ((aTop + aHeight) < (bTop)) ||
            (aTop > (bTop + bHeight)) ||
            ((aLeft + aWidth) < bLeft) ||
            (aLeft > (bLeft + bWidth))
            );
    }

    private async Task UpdateGameObjectPositions()
    {
        foreach (var go in _gameObjects)
        {
            if (go.Moved)
            {
                await _connection.SendAsync("UpdateGameObjectPosition", go);

                go.Moved = false;
            }
        }
    }

    private void InitializeGameObjects()
    {
        this._gameObjects = new List<GameObject>()
{
            new GameObject()
            {
                Id = "player1",
                LastUpdatedBy = null,
                Left = 100,
                Top = 100,
                Draggable = _playerType == Enums.ClientType.Player1,
                Width = 20,
                Height = 100
            },
            new GameObject()
            {
                Id = "player2",
                LastUpdatedBy = null,
                Left = 880,
                Top = 100,
                Draggable = _playerType == Enums.ClientType.Player2,
                Width = 20,
                Height = 100
            },
            new GameObject()
            {
                Id = "ball",
                LastUpdatedBy = null,
                Left = 500,
                Top = 250,
                Width = 20,
                Height = 20
            }
        };
    }

    /// <summary>
    /// Chiamato ogni 40 ms dal server per ridisegnare la posizione della pallina in movimento, lo sfrutto anche per ridisegnare il player
    /// </summary>
    private Task UpdateGameObjectPositionOnClient(GameObject updatedObj)
    {
        for (int i = 0; i < _gameObjects.Count; i++)
        {
            var gameObject = _gameObjects[i];
            if (_gameObjects[i] == null || !gameObject.Id.Equals(updatedObj.Id))
            {
                continue;
            }

            // Altrimenti lo riassegno, ci penserà blazor a ridisegnare l'elemento al prossimo hearthbeat
            _gameObjects[i].Top = updatedObj.Top;
            _gameObjects[i].Left = updatedObj.Left;
        }

        // Se siamo qui devo renderizzare di nuovo la UI, anche se non c'è stata interazione da parte del client
        this.StateHasChanged();

        return Task.CompletedTask;
    }

    // TODO Implementa logica per scelta del tipo di connessione
    // TODO Implementa logica per scegliere di quanto ci si può muovere e i punti che si fanno e si ricevono di conseguenza
}
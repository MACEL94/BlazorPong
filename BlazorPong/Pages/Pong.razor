@page "/pong"
@using System.Threading
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Http.Connections
@using Microsoft.AspNetCore.SignalR.Client
@implements IDisposable
@inject IJSRuntime JsRuntime;

<style>
    #player1 {
        background-color: red;
        width: 20px;
        height: 100px;
        position: absolute;
        left: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("player1"))?.LeftPx ?? "100px");
        top: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("player1"))?.TopPx ?? "100px");
    }

    #player2 {
        background-color: green;
        width: 20px;
        height: 100px;
        position: absolute;
        left: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("player2"))?.LeftPx ?? "880px");
        top: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("player2"))?.TopPx ?? "100px");
    }

    #ball {
        background-color: blue;
        width: 20px;
        height: 20px;
        position: absolute;
        left: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("ball"))?.LeftPx ?? "500px");
        top: @(_gameObjects.FirstOrDefault(g => g.Id.Equals("ball"))?.TopPx ?? "250px");
    }

    .makeRed {
        color: red
    }

    .makeGreen {
        color: green
    }
</style>

<h2 id="message">@_playerTypeMessage</h2>

<div class="row">
    @if (_connection == null || (_connection.State != HubConnectionState.Connected && _connection.State != HubConnectionState.Reconnecting))
    {
        <h4>@_connectionMessage</h4>
        <div class="form-row align-items-center">
            <div class="col-auto my-1">
                <label class="mr-sm-2 sr-only" for="inlineFormCustomSelect">Connection Type</label>
                <select class="custom-select mr-sm-2" id="inlineFormCustomSelect" @onchange=@SaveChoice>
                    @foreach (var connectionType in _connectionTypesDictionary.Keys)
                    {
                        <option value=@connectionType>@connectionType</option>
                    }
                </select>
            </div>
            <div class="col-auto my-1">
                <button type="button" @onclick="@ConnectToHub" class="btn btn-primary">Connect</button>
            </div>
        </div>
    }
    else
    {
        <div class="col makeRed">Player 1: @_player1Points</div>
        @if (_gameMessage != null)
        {
            <div class="col">@_gameMessage</div>
        }
        @if (_playerType != Enums.ClientType.Spectator && _gameMessage == null)
        {
            <button type="button" @onclick="@SetPlayerIsReady" class="btn btn-success col">Play</button>
        }
        <div class="col makeGreen">Player 2: @_player2Points</div>
    }
</div>



<div id="area">
    <div id="tophorizontalboundary"></div>
    <div id="leftverticalboundary"></div>
    @foreach (var go in _gameObjects)
    {
        // ball, player1 e player2
        <div id="@go.Id" draggable="@go.Draggable" @ondrag="@(e => MoveOnYAxisAndFlag(e, go))"></div>
    }
    <div id="bottomhorizontalboundary"></div>
    <div id="rightverticalboundary"></div>
</div>

@code {
    List<GameObject> _gameObjects = new List<GameObject>();
    HubConnection _connection;
    Dictionary<string, HttpTransportType> _connectionTypesDictionary;
    Enums.ClientType _playerType;
    double _mouseOffset = 0;
    int _player1Points;
    int _player2Points;
    string _playerTypeMessage;
    string _gameMessage;
    string _connectionMessage;
    Timer _updateServerTimer;
    private HttpTransportType _connectionTypeChoice;

    protected override void OnInitialized()
    {
        _connectionMessage = "Please select a type of connection and click 'Connect'.";
        _connectionTypesDictionary = new Dictionary<string, HttpTransportType>()
    {
            {
                "WebSockets", HttpTransportType.WebSockets
            },
            {
                "LongPolling", HttpTransportType.LongPolling
            },
            {
                "ServerSentEvents", HttpTransportType.ServerSentEvents
            },
        };
        _connectionTypeChoice = HttpTransportType.WebSockets;
    }

    private async Task ConnectToHub()
    {
        await this.SetOnbeforeunload();

#if DEBUG
        // 44364 DEVELOPMENT(IIS)
        // 443 PROD o DEV BlazorPong Env(Forced Https)
        _connection = new HubConnectionBuilder()
            .WithUrl("https://localhost/gamehub", _connectionTypeChoice)
            .WithAutomaticReconnect()
            .Build();
#else
    _connection = new HubConnectionBuilder()
        .WithUrl("https://blazorpong-dev-as.azurewebsites.net/gamehub", _connectionTypeChoice)
        .WithAutomaticReconnect()
        .Build();
#endif

        _connection.On<GameObject>("UpdateGameObjectPositionOnClient", this.UpdateGameObjectPositionOnClient);
        _connection.On<Enums.ClientType, int>("UpdatePlayerPoints", this.UpdatePlayerPoints);
        _connection.On<string>("UpdateGameMessage", this.UpdateGameMessage);

        await _connection.StartAsync();

        // Ricavo che tipo di player sono(1, 2 o spettatore)
        _playerType = await _connection.InvokeAsync<Enums.ClientType>("GetClientType");

        switch (_playerType)
        {
            case Enums.ClientType.Player1:
                _playerTypeMessage = "Sei il player1";
                break;
            case Enums.ClientType.Player2:
                _playerTypeMessage = "Sei il player2";
                break;
            default:
                _playerTypeMessage = "Sei uno spettatore";
                break;
        }

        this.GetOrInitializeGameObjects();

        // Ogni decimo di secondo controlliamo se necessario fare l'update delle collisioni al server e in caso lo mandiamo
        // Iniziamo un secondo dopo l'inizializzazione del timer
        _updateServerTimer = new Timer(UpdateServer, null, 1000, 100);
    }

    private async void UpdateGameMessage(string serverMessage)
    {
        _gameMessage = serverMessage;
        StateHasChanged();

        // Lascio che l'utente veda il messaggio finale
        await Task.Delay(10000);

        // Lo resetto a null per mostrare il pulsante play
        _gameMessage = null;

        this.StateHasChanged();
    }

    private Task UpdatePlayerPoints(Enums.ClientType clientType, int points)
    {
        switch (clientType)
        {
            case Enums.ClientType.Player1:
                _player1Points = points;
                _gameMessage = "Punto per il player1!";
                break;
            case Enums.ClientType.Player2:
                _player2Points = points;
                _gameMessage = "Punto per il player2!";
                break;
        }

        this.StateHasChanged();

        return Task.CompletedTask;
    }

    private void MoveOnYAxisAndFlag(UIDragEventArgs e, GameObject go)
    {
        if (!go.Draggable)
        {
            return;
        }

        // Calcolo prima di tutto l'offset del mouse se necessario
        if ((int)_mouseOffset == 0)
        {
            _mouseOffset = e.ClientY - go.Top;
        }

        // Non devo considerare l'offset nel calcolo
        var nextTop = e.ClientY - _mouseOffset;

        // Il top può andare da un minimo di 10 a un massimo di 400(500 - altezza player)
        if (nextTop < 0)
        {
            return;
        }
        if (nextTop < 10)
        {
            nextTop = 10;
        }
        else if (nextTop > 400)
        {
            nextTop = 400;
        }

        // Ignoro l'asse x e quindi il left, che deve rimanere sempre uguale, e imposto come mosso e quindi da inviare l'oggetto
        // Di cui si è fatto il drag
        go.Top = nextTop;
        go.Moved = true;
    }

    private async void UpdateServer(object state)
    {
        if (_playerType == Enums.ClientType.Spectator)
        {
            return;
        }

        var tempGameObjects = new List<GameObject>();
        tempGameObjects.AddRange(_gameObjects);

        await UpdateGameObjectPositions();

        var playerGameObject = tempGameObjects.FirstOrDefault(go => go.Id.Equals((_playerType == Enums.ClientType.Player1 ? "player1" : "player2")));

        if (playerGameObject != null)
        {
            await CheckForCollisionsWithPlayerAndBall(playerGameObject, tempGameObjects);
        }
    }

    private async Task CheckForCollisionsWithPlayerAndBall(GameObject playerGameObject, List<GameObject> tempGameObjects)
    {
        if (IsCollide(playerGameObject, tempGameObjects.FirstOrDefault(go => go.Id.Equals("ball"))))
        {
            if (_playerType == Enums.ClientType.Player1)
            {
                await _connection.SendAsync("OnPlayer1Hit");
            }
            else
            {
                await _connection.SendAsync("OnPlayer2Hit");
            }
        }
    }

    private bool IsCollide(GameObject gameObjectA, GameObject gameObjectB)
    {
        var aLeft = gameObjectA.Left;
        var aTop = gameObjectA.Top;
        var aWidth = gameObjectA.Width;
        var aHeight = gameObjectA.Height;
        var bLeft = gameObjectB.Left;
        var bTop = gameObjectB.Top;
        var bWidth = gameObjectB.Width;
        var bHeight = gameObjectB.Height;

        return !(
            aTop + aHeight <= bTop ||
            aTop >= bTop + bHeight ||
            aLeft + aWidth <= bLeft ||
            aLeft >= bLeft + bWidth
        );
    }

    private async Task UpdateGameObjectPositions()
    {
        foreach (var go in _gameObjects)
        {
            if (go.Moved)
            {
                await _connection.SendAsync("UpdateGameObjectPosition", go);

                go.Moved = false;
            }
        }
    }

    private async void GetOrInitializeGameObjects()
    {
        // Chiedo al server la posizione di ogni oggetto e aspetto la risposta
        this._gameObjects = await _connection.InvokeAsync<List<GameObject>>("GetGameObjects");

        // Infine setto i draggable che non dipendono dal server
        foreach (var gameObject in _gameObjects)
        {
            switch (gameObject.Id)
            {
                case "player1":
                    gameObject.Draggable = _playerType == Enums.ClientType.Player1;
                    break;
                case "player2":
                    gameObject.Draggable = _playerType == Enums.ClientType.Player2;
                    break;
            }
        }
    }

    /// <summary>
    /// Chiamato ogni 40 ms dal server per ridisegnare la posizione della pallina in movimento, lo sfrutto anche per ridisegnare il player
    /// </summary>
    private Task UpdateGameObjectPositionOnClient(GameObject updatedObj)
    {
        if (_gameMessage != null && _gameMessage != "Game started!")
        {
            _gameMessage = "Game started!";
        }

        for (int i = 0; i < _gameObjects.Count; i++)
        {
            var gameObject = _gameObjects[i];
            if (_gameObjects[i] == null || !gameObject.Id.Equals(updatedObj.Id))
            {
                continue;
            }

            // Altrimenti lo riassegno, ci penserà blazor a ridisegnare l'elemento al prossimo hearthbeat
            _gameObjects[i].Top = updatedObj.Top;
            _gameObjects[i].Left = updatedObj.Left;
        }

        this.StateHasChanged();

        return Task.CompletedTask;
    }

    public async void Dispose()
    {
        // Dispose del timer
        _updateServerTimer?.Dispose();

        // Chiusura della connessione manualmente perchè l'evento non viene chiamato dal framework
        if (_connection != null)
        {
            await _connection.StopAsync();
        }

        try
        {
            await this.UnsetOnbeforeunload();
        }
        catch
        {
            //Catch silente, perchè se l'utente si disconnette e non cambia semplicemente tab, l'evento non esiste già più.
        }
    }

    private async Task SetOnbeforeunload()
    {
        await JsRuntime.InvokeAsync<object>("blazorJSPongInterop.setOnbeforeunload", DotNetObjectRef.Create(this));
    }

    private async Task UnsetOnbeforeunload()
    {
        await JsRuntime.InvokeAsync<object>("blazorJSPongInterop.unsetOnbeforeunload", DotNetObjectRef.Create(this));
    }

    /// <summary>
    /// Metodo invocato con cui forzo il dispose in fase di chiusura dell'applicazione
    /// </summary>
    /// <returns></returns>
    [JSInvokable]
    public Task DisposePongComponent()
    {
        Dispose();
        return Task.CompletedTask;
    }

    private async void SetPlayerIsReady()
    {
        await _connection.SendAsync("SetPlayerIsReady");
        _gameMessage = "Waiting for the other player...";
        StateHasChanged();
    }

    private void SaveChoice(UIChangeEventArgs e)
    {
        _connectionTypeChoice = _connectionTypesDictionary[e.Value.ToString()];
    }
}